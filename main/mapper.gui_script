local messages = require "main.messages"
local devices = require "main.devices"
local mapper = require "main.mapper"

local STATE_MAPPING = 1
local STATE_COMPLETE = 2

local function highlight_single_input(self, lit_input)
    for _, input in ipairs(mapper.all_inputs) do
        local node = gui.get_node("lit_" .. input)
        gui.set_enabled(node, input == lit_input)
    end
end

local function set_input_name_and_prompt(self, name, prompt)
    gui.set_text(gui.get_node("current_input"), name)
    gui.set_text(gui.get_node("prompt_text"), prompt)
end

local function new_capture_data(self, input_id)
    local nodes = gui.clone_tree(gui.get_node("input_item"))
    local input_info = mapper.get_input_info(input_id)
    local capture_data = {
        trigger_name = input_info.trigger_name,
        is_skipped = false,
        root_node = nodes["input_item"],
        done_node = nodes["done"],
        skip_node = nodes["skip"],
        text_node = nodes["mapping_text"],
        icon_node = nodes["icon"],
    }
    gui.set_enabled(capture_data.root_node, true)
    gui.play_flipbook(capture_data.icon_node, "icon_" .. input_id)
    gui.set_text(capture_data.text_node, "---\n---")
    gui.set_position(capture_data.root_node, input_info.start_pos)
    gui.animate(capture_data.root_node, gui.PROP_POSITION, input_info.hold_pos, gui.EASING_OUTBACK, 0.35, 0.2)
    return capture_data
end

local function complete_mapping(self)
    self.state = STATE_COMPLETE
    highlight_single_input(self, nil)
    local prompt = "Check inputs then press ENTER to save the mapping.\nPress ESC to cancel this mapping."
    set_input_name_and_prompt(self, "Mapping Complete", prompt)
    gui.set_enabled(gui.get_node("other_controls"), false)
end

local function finalize_current_mapping(self, input_id)
    local capture_data = self.captured_inputs[input_id]
    local input_info = mapper.get_input_info(input_id)

    gui.animate(capture_data.root_node, "position.x", input_info.done_pos.x, gui.EASING_OUTSINE, 0.4)
    gui.animate(capture_data.root_node, "position.y", input_info.done_pos.y, gui.EASING_INOUTSINE, 0.5)
    gui.set_enabled(capture_data.done_node, not capture_data.is_skipped)
    gui.set_enabled(capture_data.skip_node, capture_data.is_skipped)

    if not capture_data.is_skipped then
        -- TODO: Encode the capture data to a short two-line string including
        -- input type, index, hat mask, and characters for modifier flags
        gui.set_text(capture_data.text_node, "Done")
    end
end

local function continue_mapping_next(self)
    self.active_input = self.active_input + 1
    if self.active_input > #mapper.all_inputs then
        complete_mapping(self)
        return
    end

    local input_id = mapper.all_inputs[self.active_input]
    highlight_single_input(self, input_id)

    local input_info = mapper.get_input_info(input_id)
    set_input_name_and_prompt(self, input_info.name, input_info.prompt)

    self.captured_inputs[input_id] = new_capture_data(self, input_id)
end

local function skip_input_mapping(self)
    local input_id = mapper.all_inputs[self.active_input]
    local capture_data = self.captured_inputs[input_id]
    capture_data.is_skipped = true
    finalize_current_mapping(self, input_id)
    continue_mapping_next(self)
end

local function capture_input_mapping(self)
    local input_id = mapper.all_inputs[self.active_input]
    local capture_data = self.captured_inputs[input_id]
    -- TODO: Store detected input settings in capture_data
    continue_mapping_next(self)
end

local function begin_mapping(self)
    self.captured_inputs = {}
    self.active_input = 0
    self.state = STATE_MAPPING
    continue_mapping_next(self)
end

local function reset(self, gamepad_index)
    local root_node = gui.get_node("root")
    gui.set_enabled(root_node, true)
    gui.set_enabled(gui.get_node("other_controls"), true)

    self.gamepad_index = gamepad_index

    local name_node = gui.get_node("gamepad_name")
    local name = devices.gamepads[gamepad_index] or "Unknown"
    gui.set_text(name_node, name)

    begin_mapping(self)
end

local function disable(self)
    if self.captured_inputs then
        for input_id, capture_data in pairs(self.captured_inputs) do
            gui.delete_node(capture_data.root_node)
        end
        self.captured_inputs = nil
    end

    local root_node = gui.get_node("root")
    gui.set_enabled(root_node, false)
    self.gamepad_index = -1
    self.state = nil
end

-- Defold lifecycle functions

function init(self)
    self.gamepad_index = -1
    highlight_single_input(self, nil)
end

function on_message(self, message_id, message, sender)
    if message_id == msg.START_MAPPING then
        reset(self, message.gamepad_index)
        msg.post(".", msg.ENABLE)
        msg.post(".", msg.ACQUIRE_INPUT_FOCUS)
    elseif message_id == msg.DISABLE then
        disable(self)
        msg.post(".", msg.RELEASE_INPUT_FOCUS)
    elseif message_id == msg.DEVICES_UPDATED then
        if devices.gamepads[self.gamepad_index] == nil then
            msg.post(messages.main_gui, msg.MAPPING_CANCELLED)
        end
    end
end

function on_input(self, action_id, action)
    if action_id == hash("key_esc") and action.pressed then
        msg.post(messages.main_gui, msg.MAPPING_CANCELLED)
    elseif action_id == hash("key_backspace") and action.pressed then
        if self.state == STATE_MAPPING then
            skip_input_mapping(self)
        end
    elseif action_id == hash("key_enter") and action.pressed then
        if self.state == STATE_COMPLETE then
            -- TODO: save mapping
            msg.post(messages.main_gui, msg.MAPPING_COMPLETED, { status = "Mapping complete." })
        end
    elseif action_id == hash("raw") and action.gamepad == self.gamepad_index then
    end
end
